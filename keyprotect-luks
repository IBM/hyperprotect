#!/usr/bin/env python3
#
# SPDX-License-Identifier: Apache-2.0
#
# Key Protect Interface for keyprotect-LUKS service via Python
#
# Nayna Jain <nayna@linux.ibm.com>, George Wilson <gcwilson@linux.ibm.com>
#
# Copyright (C) 2021 IBM Corp.
#

import configparser
import argparse
import os
import subprocess
import sys
import keyprotect
from keyprotect import bxauth

CONFIG_FILE = '/etc/keyprotect-luks.ini'
KEY_BYTES = 32
WRAPPED_KEY_DIR = '/var/lib/keyprotect-luks'
KEY_TYPES = ('logon', 'user')
BLOB_FILE = WRAPPED_KEY_DIR + '/api-key-blob.txt'

#
#  Parse config file
#

def parse_config(config_file):
    config = configparser.ConfigParser(defaults=None)
    try:
        config.read(CONFIG_FILE)
    except:
        print('Error reading configuration file ' + config_file + ': ' + sys.exc_info()[0], file=sys.stderr)
    try:
        if config['KP'] == None:
            pass
    except:
        print('KP section missing from configuration file ' + config_file, file=sys.stderr)
        exit(1)
    for section in ('api_key', 'region', 'service_instance_id', 'endpoint_url'):
        try:
            if config['KP'][section] == None:
                print(section + ' value missing from configuration file ' + config_file, file=sys.stderr)
                exit(1)
        except:
            print(section + ' key missing from configuration file ' + config_file, file=sys.stderr)
            exit(1)
    try:
        if config['KP']['default_crk_uuid'] == None:
            pass
    except:
        config['KP']['default_crk_uuid'] = ''
    return config


#
#  Parse args
#

def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('op', choices=['list', 'createcrk', 'createstd', 'get', 'wrap', 'genwrap', 'unwrap', 'process', 'delete'])
    parser.add_argument('--uuid', default=None)
    parser.add_argument('--dek', default=None)
    parser.add_argument('--name', default=None)
    args = parser.parse_args()
    return args

#
# Check for TPM special case, attempt unseal, replace config['KP']['api_key'] on success
#

def tpm_unseal(config):
    if config['KP']['api_key'] == 'TPM':
        print('Unsealing API key from TPM')
        unseal_proc = subprocess.Popen(('tpm_unsealdata', '-z', '-i', BLOB_FILE), stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        raw_plaintext, perr = unseal_proc.communicate()
        if unseal_proc.returncode != 0:
            print('Cannot obtain API key from TPM: ' + perr.decode('utf-8') + ", rc =", unseal_proc.returncode, file=sys.stderr)
            exit(1)
        print(perr.decode('utf-8'), end='', flush=True)
        config['KP']['api_key'] = raw_plaintext.decode('utf-8')

#
#  Initialize key protect
#

def init_keyprotect(api_key, region, service_instance_id, endpoint_url):
    tm = bxauth.TokenManager(api_key=api_key)
    kp = keyprotect.Client(credentials=tm,
                           region=region,
                           service_instance_id=service_instance_id,
                           endpoint_url=endpoint_url)
    return kp

#
#  Key Protect LUKS class
#

class key_protect_luks:

    #
    #  Constructor
    #

    def __init__(self, config, args, kp):
        self.config = config
        self.args = args
        self.kp = kp

    #
    #  Iterate over keys in a directory for a given type and create keyring keys
    #

    def process_keys_of_type(self, key_type):
        wrapped_key_dir_of_type = WRAPPED_KEY_DIR + '/' + key_type
        for filename in os.listdir(wrapped_key_dir_of_type):
            print(filename, end=' ')
            file = open(wrapped_key_dir_of_type + '/' + filename)
            ciphertext = file.read()
            plaintext = kp.unwrap(key_id=args.uuid, ciphertext=ciphertext)
            keyctl_proc = subprocess.Popen(('keyctl', 'padd', key_type, filename, '@u'), stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            # keyctl_proc = subprocess.Popen(('cat > /tmp/myoutfile'), shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            pout, perr = keyctl_proc.communicate(input=plaintext)
            print(pout.decode('utf-8'), end='', flush=True)
            print(perr.decode('utf-8'), end='', flush=True)

    #
    #  List Key Protect keys
    #

    def op_list(self):
        keys = kp.keys()
        for key in kp.keys():
            print('%s\t%s' % (key['id'], key['name']))

    #
    #  Create a new root key
    #

    def op_createcrk(self):
        if args.name == None:
            print('Missing CRK --name option', file=sys.stderr)
            exit(1)
        else:
            rootkey = kp.create(name=args.name, root=True)
            print('Created key %s' % rootkey['id'])

    #
    #  Create a new standard key
    #

    def op_createstd(self):
        print("test createstd")
        if args.name == None:
            print('Missing standard key --name option', file=sys.stderr)
            exit(1)
        else:
            stdkey = kp.create(name=args.name, root=False)
            print('Created key %s' % stdkey['id'])

    #
    #  Take the key specified by --dek,  wrap it with a CRK specified by --uuid or default_crk_uuid, and write it to stdout
    #

    def op_wrap(self):
        if args.uuid == None:
            if config['KP']['default_crk_uuid'] == '':
                print('No default CRK UUID in config file and missing CRK --uuid option', file=sys.stderr)
                exit(1)
            else:
                args.uuid = config['KP']['default_crk_uuid']
        if args.dek == None:
            print('Missing --dek for wrap op', file=sys.stderr)
            exit(1)
        wrappedkey = kp.wrap(args.uuid, plaintext=args.dek.encode('utf-8'))
        ciphertext = wrappedkey.get('ciphertext')
        plaintext = kp.unwrap(key_id=args.uuid, ciphertext=ciphertext)
        print(ciphertext)

    #
    #  Get the Key Protect key specified by --uuid and print its info
    #

    def op_get(self):
        if args.uuid == None:
            print('Missing --uuid for get op', file=sys.stderr)
            exit(1)
        else:
            key = kp.get(args.uuid)
            print(key)

    #
    #  Generate a 32-byte random key, wrap it with the root key specified by --uuid or default_crk_uuid, and write it to stdout
    #

    def op_genwrap(self):
        if args.uuid == None:
            if config['KP']['default_crk_uuid'] == '':
                print('No default CRK UUID in config file and missing CRK --uuid option', file=sys.stderr)
                exit(1)
            else:
                args.uuid = config['KP']['default_crk_uuid']
        wrappedkey = kp.wrap(args.uuid, plaintext=os.urandom(KEY_BYTES))
        ciphertext = wrappedkey.get('ciphertext')
        plaintext = kp.unwrap(key_id=args.uuid, ciphertext=ciphertext)
        print(ciphertext)

    #
    #  Read a wrapped key from stdin, unwrap it with the key specified by --uuid or default_crk_uuid, and write it to stdout
    #

    def op_unwrap(self):
        if args.uuid == None:
            if config['KP']['default_crk_uuid'] == '':
                print('No default CRK UUID in config file and missing CRK --uuid option', file=sys.stderr)
                exit(1)
            else:
                args.uuid = config['KP']['default_crk_uuid']
        ciphertext = sys.stdin.read()
        plaintext = kp.unwrap(key_id=args.uuid, ciphertext=ciphertext)
        sys.stdout.buffer.write(plaintext)

    #
    #  Read keys from /var/lib/keyprotect-luks and add them to the kernel keyring
    #

    def op_process(self):
        if args.uuid == None:
            if config['KP']['default_crk_uuid'] == '':
                print('No default CRK UUID in config file and missing CRK --uuid option', file=sys.stderr)
                exit(1)
            else:
                args.uuid = config['KP']['default_crk_uuid']
        for key_type in KEY_TYPES:
            self.process_keys_of_type(key_type)

    #
    #  Delete Key Protect key specified by --uuid
    #

    def op_delete(self):
        if args.uuid == None:
            print('Missing root key --uuid option', file=sys.stderr)
            exit(1)
        else:
            deleted_key = kp.delete(args.uuid)
            print('Deleted key %s' % args.uuid)

    opswitch = {
        'list': op_list,
        'createcrk': op_createcrk,
        'createstd': op_createstd,
        'wrap': op_wrap,
        'get': op_get,
        'genwrap': op_genwrap,
        'unwrap': op_unwrap,
        'process': op_process,
        'delete': op_delete
    }

    def run_op(self, op):
        func = self.opswitch.get(op, None)
        return func(self)

#
#  Main
#

# Read config file and parse args

config = parse_config(CONFIG_FILE)
args = parse_args()

# Check for TPM case

tpm_unseal(config)

# Initialize the key management service client as specified in Authentication

kp = init_keyprotect(config['KP']['api_key'],
                     config['KP']['region'],
                     config['KP']['service_instance_id'],
                     config['KP']['endpoint_url'])

# Instantiate keyprotect-luks object

kpl = key_protect_luks(config, args, kp)

# Process op

kpl.run_op(args.op)
